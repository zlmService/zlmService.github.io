---
title: 杂项
date: 2016-05-07 23:21:30
tags: 杂项
---

### Android中跨进程通讯有几种方式
1.通过Intent 设置Action匹配规则 比如打开系统通话应用

	IntentcallIntent=newIntent(Intent.ACTION_CALL,Uri.parse("tel:12345678");
	startActivity(callIntent);
2.通过 ContentProvider 访问联系人信息

3.广播 Broadcast 获取 手机电量等 信息

4.AIDL

### 强引用，软引用，弱引用

- 强引用 如果一个对象具有强引用，那垃圾回收器绝不会回收它   
- 软引用 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存  软引用可用来实现内存敏感的高速缓存。   
- 弱引用 不管内存是否足够，只要垃圾回收器扫描到它 ，就会把它给回收掉  不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。


### Android动画
- 帧动画，类似电影播放一样，由一个图片一个图片组成
- 补间动画，是对某个View进行一系列的动画的操作，包括淡入淡出（Alpha），缩放（Scale），平移（Translate），旋转（Rotate）四种模式。
- 属性动画，不再仅仅是一种视觉效果了，而是一种不断地对值进行操作，并将值赋到指定对象的指定属性上，可以是任意对象的任意属性


### CursorLoader原理
整个过程其实应用了 观察者模式，通常我们会在ContenProvider的query方法中调用setNotificationUri 这句话的作用其实就是告诉Cursor的观察者 数据发生了变化，
- 通过ContentPorvider和ContentResolver使得数据发生了改变
- ContentProvider通知Cursor的观察者数据发生了改变
- Cursor通知CursorLoader的观察者数据发生了改变
- CursorLoader通过ContentProvider加载新的数据
- ContentPovider向DataBase请求新的数据
- CursorLoader调用CursorAdapter#changeCursor,用封装了新数据的Cursor替换旧的Cursor
-  CursorAdapter告知AdapterView的观察者有新的数据
- AdapterView重新加载并显示数据


### ListView优化
- 尽量宽高设置成固定的（避免内容listview重新渲染 加载）
- 使用ViewHolder 避免每次getView的时候 重复调用 findViewById
- convertView 
- 使用分页加载 
- 避免在getView中做耗时操作
- 如果item有图片的加载，一定要对图片进行优化压缩缓存，

### 事件传递
- dispatchTouchEvent	用来分派事件 其中调用了onInterceptTouchEvent()和onTouchEvent()，一般不重写该方法
- onInterceptTouchEvent	用来拦截事件 ViewGroup类中的源码实现就是{return false;}表示不拦截该事件，事件将向下传递（传递给其子View）；若手动重写该方法，使其返回true则表示拦截，事件将终止向下传递，事件由当前ViewGroup类来处理，就是调用该类的onTouchEvent()方法
- onTouchEvent	用来处理事件 返回true则表示该View能处理该事件，事件将终止向上传递（传递给其父View）；返回false表示不能处理，则把事件传递给其父View的onTouchEvent()方法来处理
- 记忆功能：比如说一个onClick事件，他其实有2个事件，第一个ACTION_DOWN，第二个ACTION_UP，当第一个ACTIONDOWN传递到某View的时候，他是怎么记录该事件是否被下面的View给处理成功了（因为，如果子View没有成功处理该事件的话，这个事件会一次回传上来）通过是否向上传递来记录ACTION_DOWN是否被处理成功了，如果子View处理成功了，ACTION_UP也传递到子View中，如果没有处理成功，ACTION_UP的时候也不会在传递到子View中，他会直接调用自己的onTouchEvent方法来处理。
- 关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。

### 设计模式：
- 装饰模式：在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
- 工厂模式：就是不需要new了，  它会自动帮你实现实例化。  
getSystemService（String name）根据传过来的条件，生成对应的对象。
- 观察者模式：定义对象间一对多的关系，当一个发生变化的时候，所依赖它的所有对象，都得到通知并自动更新。
- 单例模式：确保该类只有一个实例存在。

### AsyncTask内部实现，适用的场景
- AsyncTask内部也是Handler机制来完成的，只不过Android提供了执行框架来提供线程池来执行相应地任务，因为线程池的大小问题，所以AsyncTask只应该用来执行耗时时间较短的任务，比如HTTP请求，大规模的下载和数据库的更改不适用于AsyncTask，因为会导致线程池堵塞，没有线程来执行其他的任务，导致的情形是会发生AsyncTask根本执行不了的问题。

### FragmentPagerAdapter和FragmentStatePagerAdapter
- FragmentPageAdapter该类缓存当前Fragment的左边和右边同时保存到内存之中，适合用于那些相对静态的页，数量也较少的那种。
- FragmentStatePagerAdapter适合数据动态性较大，需要处理很多页的情况，它也继承PagerAdapter，但是它只保留当前页面，当页面离开视线的时候，就会被清除，释放资源。

### 自定义View
- 自定义View  
解释什么情况下 引发的 需要去自定义控件
如果是自定义一个View  首先我会去分析这个View  需要哪些自定义的属性 然后去编写  在自定义View的构造方法中去获取  获取到以后 我会重写他测量的方法 然后觉得这个View 到底占据多大的空间  测量完成后 我会去复写他的onDraw方法 去绘制我们的View 到底显示什么样的形状   这就是自定义View 的过程
- 自定义ViewGroup
首先测量决定 ViewGroup的自身大小  还有一个职责就是去测量 它子View 的大小  给子View 一个参考值 
然后完成测量 他的最主要一个任务就是 onLayout 去布局 去决定他ziView的位置显示的规则  比如是垂直的还是相对的 如果没有手势与用户交互的话  那他主要的也就是测量和一个Layout的过程  如果有和用户交互的话 那么还需要去考虑重写onTouchEvent 决定和用户如何交互  还有onInterceptTOuchEvent（ViewGroup）的情况下 你觉得这个手势是你应当去拦截的（从down到move到up 整个过程）
- getHeight()获取到的时候 在手机上面显示出来的高度
- getMeasuredHeight() 获取到的是 显示的高度+隐藏的高度
- getWidth（）View在設定好佈局後整個View的寬度。
- getMeasuredWidth（）對View上的內容進行測量後得到的View內容佔據的寬度

### Canvas save()和restore()
- save：用来保存Canvas的状态。save之后，可以调用Canvas的平移、放缩、旋转、错切、裁剪等操作。
- restore：用来恢复Canvas之前保存的状态。防止save后对Canvas执行的操作对后续的绘制有影响。
- save和restore要配对使用（restore可以比save少，但不能多），如果restore调用次数比save多，会引发Error。

---
### LayoutInflate.inflate(int resource, ViewGroup root, boolean attachToRoot)参数
- resource：需要加载布局文件的id，意思是需要将这个布局文件中加载到Activity中来操作。
- root：需要附加到resource资源文件的根控件，什么意思呢，就是inflate()会返回一个View对象，如果第三个参数attachToRoot为true，就将这个root作为根对象返回，否则仅仅将这个root对象的LayoutParams属性附加到resource对象的根布局对象上，也就是布局文件resource的最外层的View上，比如是一个LinearLayout或者其它的Layout对象。
- attachToRoot：是否将root附加到布局文件的根视图上
  
### DOM、SAX、PULL区别
- DOM：一次性把整个xml都加载进来，当文件比较大的时候速度比较慢。好处是：可以随时访问到某个节点的相邻节点，并且对xml文档的插入也非常的方便。
- SAX：通过事件驱动的方式，它会判断当前读到的字符是否符合xml语法中的某部分，如果符合就触发事件。所谓事件，其实就是一些回调（callback）方法，这些方法(事件)定义在ContentHandler接口。
- PULL：允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。

### Volley
- 创建一个 RequestQueue queue=Volley.newRequestQueue(context);
- 创建一个StringRequest对象 StringRequest s=new StringRequest(URL,响应成功回调，响应失败回调)
- 强StringRequest对象添加到RequestQueue里面  
- 如果是一个post请求的话 就要在 StringRequest s=new StringRequest（）{ 内部中重写一个onParams方法 在里面的Map集合中 添加post请求的数据 }
- StringRequest   JSONObjectRequest ImageRequest  不同的需求 对应不同的对象
- ImageLoader 使用缓存  
    ①ImageLoader il=new ImageLoader(RequestQueue,new ImageCache());
    ②ImageLoader.ImageListener listener=ImageLoader.getImageListener(ImageView，默认图片，出错图片);
    ③il.get(url,listener,winth,height); 
- 使用 NetWorkImageView 控件   显示图片 并且缓存
	①netWorkImageView.setDefault(默认图片);
	②netWorkImageView.setError(出错图片);
	③netWorkImageView.setImageUrl(url,new ImageLoader(RequestQueue,new ImageCache());
- 内部原理：RequestQueue queue=Volley.newRequestQueue(context) 内部会启动五个线程 在等待处理数据
	当RequestQueue.add（）方法来添加一条网路请求的时候，这条请求会先加入缓存队列中，如果在缓存中可以找到对应的结果，就直接读取缓存并且解析，然后回调给主线程，如果在缓存中没有找到结果，就将这条请求加入到网络请求队列中，然后处理发送HTTP请求，解析响应结果，写入缓存，并回调给主线程。

---
### 屏幕适配
- weight  dp   sp
- layout_sw600dp   最小宽度600dp  不区分是否是 横屏还是竖屏 
在这个文件夹下的布局文件 只要宽度大于600dp 就会使用这里面布局

- layout-sw600dp-port 是垂直方向所用的布局
- layout-sw600dp-land 是水平方向所用的布局

---
### Retrofit原理
其实Retrofit无非就是让用户创建接口，使用自己指定的规则进行网络访问，把接口传入Retrofit，接口上附着的规则由Retrofit进行层层解析后，再进行实际的网络调用。

Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了Java动态代理的方式，动态的将这个接口的注解“翻译”成一个HTTP请求，最后再执行这个HTTP请求

---
### 序列化
### 序列化的原因
- 当android传递的参数是Bean对象的时候，需要对Bean对象实现序列化。（2个Activity之间需要传递一个Bean对象）
- 永久性保存对象，保存对象的字节序列到本地文件中，
- 对象在网络中传递
- 对象在IPC间传递

### 两种序列化的区别
- Serializable：在序列化的时候会产生大量的临时变量，从而引起频繁的GC，但是当 永久性保存对象，保存对象的字节序列到本地文件中，推荐使用Serializable
- Parcelable 效率高，速度快，适用于在网络中传递对象，或者序列化在进程间传递对象，推荐使用Parcelable

---
### 多进程引发的问题
- 静态成员和单例模式失效：不同的虚拟机访问同一个类的对象，会产生多个副本，他们互不干扰。
- 线程同步机制失效：因为不是一片内存了，所以进程所的不是同一个对象
- SharedPreferences的可靠性下降：不支持两个进程同时去执行写的操作，否则会有几率导致数据丢失
- Application会多次创建：不同的进程，需要分配不同的虚拟机，也就是启动一个应用，所有就会创建新的Application

---
### 图片圆角的实现
- 通过设置图片本身：图片本身其实就是一个矩形，然后获取这个Bitmap的宽高new一个画布出来，然后在canvas有一个方法，绘制圆角矩形的方法，然后把圆角的大小传进进去，先绘制一个圆角矩形，然后在绘制一个Bitmap在这个矩形的上面，最终返回这个圆角bitmap，从而实现了圆角的图片.
- 自定义ImageView：

---

### Android:drawable 放一个drawable资源
- android:state_pressed 是否按下，如一个按钮触摸或者点击。
- android:state_focused 是否取得焦点，比如用户选择了一个文本框。
- android:state_hovered 光标是否悬停，通常与focused state相同，它是4.0的新特性
- android:state_selected 被选中，它与focus state并不完全一样，如一个list view 被选中的时候，它里面的各个子组件可能通过方向键，被选中了。
- android:state_checkable 组件是否能被check。如：RadioButton是可以被check的。
- android:state_checked 被checked了，如：一个RadioButton可以被check了。
- android:state_enabled 能够接受触摸或者点击事件
- android:state_activated 被激活(这个麻烦举个例子，不是特明白)
- android:state_window_focused 应用程序是否在前台，当有通知栏被拉下来或者一个对话框弹出的时候应用程序就不在前台了

## 文章
#### [AS导出jar包](http://yifeiyuan.me/2015/09/17/AndroidStudio%E5%AF%BC%E5%87%BAJar%E5%8C%85/)

#### [混淆](http://www.jianshu.com/p/60e82aafcfd0)

#### [使用Gradle管理Android](http://www.flysnow.org/2015/03/30/manage-your-android-project-with-gradle.html)

#### [Android API](https://developer.android.com/guide/index.html)

#### [Android官方培训](http://hukai.me/android-training-course-in-chinese/index.html)
